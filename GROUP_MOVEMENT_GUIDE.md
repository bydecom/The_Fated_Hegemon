# üéñÔ∏è Group Movement & Formation Guide

## M·ª•c ti√™u

Khi ng∆∞·ªùi ch∆°i ch·ªçn nhi·ªÅu units v√† ra l·ªánh di chuy·ªÉn, thay v√¨ t·∫•t c·∫£ ƒë·ªï x√¥ v·ªÅ m·ªôt ƒëi·ªÉm, ch√∫ng s·∫Ω:
1. **X·∫øp h√†ng formation** (circle, square, line, wedge, column)
2. **T·ª± ƒë·ªông t·∫•n c√¥ng enemies** g·∫∑p tr√™n ƒë∆∞·ªùng ƒëi (Attack-Move)
3. **Gi·ªØ kho·∫£ng c√°ch** v·ªõi nhau (kh√¥ng ƒë·∫©y chen)

---

## üéØ Component: AttackMoveTarget

### Kh√°i ni·ªám

`AttackMoveTarget` component kh√°c v·ªõi `MoveTarget` th√¥ng th∆∞·ªùng:

| Feature | MoveTarget | AttackMoveTarget |
|---------|------------|------------------|
| Di chuy·ªÉn ƒë·∫øn ƒëi·ªÉm | ‚úÖ | ‚úÖ |
| B·ªè qua enemies | ‚úÖ | ‚ùå Auto-engage |
| V·ªÅ ƒë√≠ch sau khi kill | ‚ùå | ‚úÖ Ti·∫øp t·ª•c v·ªÅ ƒë√≠ch |

### Code

```javascript
import { AttackMoveTarget } from './ecs/components/AttackMoveTarget.js';

// T·∫°o attack-move command
const attackMove = new AttackMoveTarget(destinationX, destinationY);
ecsWorld.addComponent(unitId, 'attackMoveTarget', attackMove);
```

---

## üèõÔ∏è Manager: FormationManager

### API Ch√≠nh

#### 1. Calculate Formation Positions

```javascript
import { FormationManager, FORMATION_TYPE } from '../managers/FormationManager.js';

const formationManager = new FormationManager();

// Input
const unitIds = ['unit1', 'unit2', 'unit3', 'unit4', 'unit5'];
const centerX = 500;
const centerY = 500;

// Calculate positions
const positions = formationManager.calculateFormationPositions(
    unitIds,
    centerX,
    centerY,
    FORMATION_TYPE.CIRCLE,  // ho·∫∑c SQUARE, LINE, WEDGE, COLUMN
    30  // spacing (optional, default = 30)
);

// Output: Map { 
//   'unit1' => { x: 500, y: 530 },
//   'unit2' => { x: 530, y: 500 },
//   ...
// }
```

#### 2. Formation Types

```javascript
// CIRCLE - Bao quanh center
FORMATION_TYPE.CIRCLE

// SQUARE - L∆∞·ªõi vu√¥ng
FORMATION_TYPE.SQUARE

// LINE - 1 h√†ng ngang
FORMATION_TYPE.LINE

// WEDGE - V-shape (cavalry charge)
FORMATION_TYPE.WEDGE

// COLUMN - H√†ng d·ªçc (march)
FORMATION_TYPE.COLUMN
```

#### 3. Calculate Group Center

```javascript
const selectedUnits = ['unit1', 'unit2', 'unit3'];
const center = formationManager.calculateGroupCenter(selectedUnits, ecsWorld);
// Returns: { x: avgX, y: avgY }
```

#### 4. Formation Facing Point

```javascript
// T·∫°o formation h∆∞·ªõng v·ªÅ m·ªôt ƒëi·ªÉm (e.g., enemy base)
const positions = formationManager.calculateFormationFacingPoint(
    unitIds,
    centerX,      // Formation center
    centerY,
    targetX,      // Point to face
    targetY,
    FORMATION_TYPE.WEDGE,
    30
);
// Formation s·∫Ω t·ª± ƒë·ªông xoay ƒë·ªÉ "nh√¨n" v·ªÅ (targetX, targetY)
```

---

## üîß T√≠ch h·ª£p v√†o DemoScene

### B∆∞·ªõc 1: Setup FormationManager

```javascript
// src/scenes/DemoScene.js
import { FormationManager, FORMATION_TYPE } from '../managers/FormationManager.js';
import { AttackMoveTarget } from '../ecs/components/AttackMoveTarget.js';

export class DemoScene extends Phaser.Scene {
    create() {
        // ... existing code ...
        
        // ‚≠ê T·∫°o Formation Manager
        this.formationManager = new FormationManager();
        
        // ‚≠ê Default formation type (c√≥ th·ªÉ thay ƒë·ªïi b·∫±ng UI)
        this.currentFormationType = FORMATION_TYPE.CIRCLE;
    }
}
```

### B∆∞·ªõc 2: S·ª≠a handlePointerDown - Right Click

```javascript
// Thay th·∫ø logic di chuy·ªÉn c≈©
handlePointerDown(pointer) {
    // ... existing left click logic ...
    
    // ‚≠ê RIGHT CLICK - GROUP MOVEMENT WITH FORMATION
    if (pointer.rightButtonDown()) {
        const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
        const targetId = this.findUnitIdAtWorldPoint(worldPoint);
        
        if (targetId && this.selectedEntities.size > 0) {
            // ‚≠ê ATTACK-MOVE TO ENEMY
            this.issueAttackMoveCommand(targetId, worldPoint);
        } 
        else if (this.selectedEntities.size > 0) {
            // ‚≠ê MOVE TO POINT WITH FORMATION
            this.issueMoveWithFormation(worldPoint);
        }
    }
}
```

### B∆∞·ªõc 3: Issue Move with Formation

```javascript
issueMoveWithFormation(worldPoint) {
    const selectedArray = Array.from(this.selectedEntities);
    
    // ‚≠ê T√≠nh formation positions
    const formationPositions = this.formationManager.calculateFormationPositions(
        selectedArray,
        worldPoint.x,
        worldPoint.y,
        this.currentFormationType,  // CIRCLE, SQUARE, etc.
        35  // Spacing
    );
    
    // ‚≠ê G√°n t·ª´ng unit m·ªôt ƒëi·ªÉm ri√™ng
    formationPositions.forEach((targetPos, unitId) => {
        const entity = this.ecsWorld.entities.get(unitId);
        if (!entity) return;
        
        const ai = entity.get('ai');
        const behavior = entity.get('behavior');
        
        if (ai && behavior) {
            // Clear target c≈©
            ai.clearTarget();
            
            // Pathfinding ƒë·∫øn v·ªã tr√≠ formation
            const pos = entity.get('position');
            const startGridPos = this.gridManager.worldToGrid(pos.x, pos.y);
            const endGridPos = this.gridManager.worldToGrid(targetPos.x, targetPos.y);
            
            this.pathfindingManager.findPath(startGridPos, endGridPos, (path) => {
                if (path) {
                    ai.setPath(path);
                    behavior.setBehavior('followPath');
                }
            });
        }
    });
}
```

### B∆∞·ªõc 4: Issue Attack-Move Command

```javascript
issueAttackMoveCommand(targetId, worldPoint) {
    // ‚≠ê T·∫°o formation quanh target
    const selectedArray = Array.from(this.selectedEntities);
    const formationPositions = this.formationManager.calculateFormationPositions(
        selectedArray,
        worldPoint.x,
        worldPoint.y,
        FORMATION_TYPE.CIRCLE,  // Attack t·ª´ m·ªçi h∆∞·ªõng
        50  // Spacing r·ªông h∆°n cho combat
    );
    
    formationPositions.forEach((targetPos, unitId) => {
        const entity = this.ecsWorld.entities.get(unitId);
        if (!entity) return;
        
        const ai = entity.get('ai');
        const behavior = entity.get('behavior');
        
        if (ai && behavior) {
            // ‚≠ê Set AttackMoveTarget component
            const attackMove = new AttackMoveTarget(targetPos.x, targetPos.y);
            this.ecsWorld.addComponent(unitId, 'attackMoveTarget', attackMove);
            
            // Start chase target
            ai.setTargetId(targetId);
            behavior.setBehavior('chase', { manualAttack: true });
        }
    });
}
```

---

## üß† BehaviorSystem - Handle Attack-Move

C·∫≠p nh·∫≠t `BehaviorSystem.js` ƒë·ªÉ x·ª≠ l√Ω `AttackMoveTarget`:

```javascript
// Trong processBehavior(), th√™m case m·ªõi
case 'attackMove':
    this.handleAttackMove(entityId, components, behavior, position, velocity, deltaTime);
    break;

// Method m·ªõi
handleAttackMove(entityId, components, behavior, position, velocity, deltaTime) {
    const attackMoveTarget = components.get('attackMoveTarget');
    const ai = components.get('ai');
    
    if (!attackMoveTarget || !ai) {
        behavior.setBehavior('idle');
        return;
    }
    
    // ‚≠ê PRIORITY 1: N·∫øu c√≥ enemy trong t·∫ßm nh√¨n ‚Üí CHASE
    const factionSystem = this.ecsWorld.systems.find(s => s.constructor.name === 'FactionSystem');
    if (factionSystem) {
        const enemies = factionSystem.findEnemiesInRange(
            components,
            this.ecsWorld.entities,
            ai.config.detectionRange,
            position
        );
        
        if (enemies.length > 0) {
            // Engage nearest enemy
            const nearestEnemy = enemies[0];
            ai.setTargetId(nearestEnemy.entityId);
            attackMoveTarget.engageEnemy(nearestEnemy.entityId);
            behavior.setBehavior('chase', { manualAttack: true });
            return;
        }
    }
    
    // ‚≠ê PRIORITY 2: N·∫øu kh√¥ng c√≥ enemy ‚Üí Ti·∫øp t·ª•c v·ªÅ destination
    const dx = attackMoveTarget.destinationX - position.x;
    const dy = attackMoveTarget.destinationY - position.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < 10) {
        // ‚úÖ ƒê√£ ƒë·∫øn ƒë√≠ch
        this.ecsWorld.removeComponent(entityId, 'attackMoveTarget');
        behavior.setBehavior('idle');
        velocity.x = 0;
        velocity.y = 0;
    } else {
        // üö∂ Di chuy·ªÉn v·ªÅ ƒë√≠ch
        const speed = ai.config.speed || 100;
        velocity.x = (dx / distance) * speed;
        velocity.y = (dy / distance) * speed;
    }
}
```

### Sau khi kill enemy, quay l·∫°i Attack-Move

```javascript
// Trong handleAttack(), khi target ch·∫øt
if (!targetComponents || targetHealth.isDead()) {
    const attackMoveTarget = components.get('attackMoveTarget');
    
    if (attackMoveTarget) {
        // ‚≠ê Quay l·∫°i destination
        attackMoveTarget.resetToDestination();
        behavior.setBehavior('attackMove');
    } else {
        behavior.setBehavior('idle');
    }
    
    ai.clearTarget();
    return;
}
```

---

## üé® UI Controls (Optional)

Cho ph√©p ng∆∞·ªùi ch∆°i ch·ªçn formation type:

```javascript
// UIScene.js
createFormationButtons() {
    const formations = [
        { type: FORMATION_TYPE.CIRCLE, icon: '‚≠ï' },
        { type: FORMATION_TYPE.SQUARE, icon: '‚¨ú' },
        { type: FORMATION_TYPE.LINE, icon: '‚ûñ' },
        { type: FORMATION_TYPE.WEDGE, icon: 'üî∫' },
        { type: FORMATION_TYPE.COLUMN, icon: 'ü™ú' }
    ];
    
    formations.forEach((formation, index) => {
        const button = this.add.text(
            10, 
            100 + index * 30, 
            formation.icon, 
            { fontSize: '20px' }
        ).setInteractive();
        
        button.on('pointerdown', () => {
            this.scene.get('DemoScene').currentFormationType = formation.type;
            console.log(`Formation changed to: ${formation.type}`);
        });
    });
}
```

---

## üß™ Testing

### Test Formation Types

```javascript
// DemoScene.js - Th√™m keyboard shortcuts
create() {
    // ... existing code ...
    
    // ‚≠ê Formation shortcuts
    this.input.keyboard.on('keydown-ONE', () => {
        this.currentFormationType = FORMATION_TYPE.CIRCLE;
        console.log('Formation: CIRCLE');
    });
    
    this.input.keyboard.on('keydown-TWO', () => {
        this.currentFormationType = FORMATION_TYPE.SQUARE;
        console.log('Formation: SQUARE');
    });
    
    this.input.keyboard.on('keydown-THREE', () => {
        this.currentFormationType = FORMATION_TYPE.LINE;
        console.log('Formation: LINE');
    });
    
    this.input.keyboard.on('keydown-FOUR', () => {
        this.currentFormationType = FORMATION_TYPE.WEDGE;
        console.log('Formation: WEDGE');
    });
    
    this.input.keyboard.on('keydown-FIVE', () => {
        this.currentFormationType = FORMATION_TYPE.COLUMN;
        console.log('Formation: COLUMN');
    });
}
```

### Test scenario

1. **Ch·ªçn 10 units** (drag select)
2. **Press "1"** ƒë·ªÉ ch·ªçn CIRCLE formation
3. **Right-click** v√†o m·ªôt ƒëi·ªÉm xa
4. **Observe**: Units x·∫øp th√†nh h√¨nh tr√≤n khi ƒë·∫øn ƒë√≠ch

---

## üìä Performance Tips

### 1. Limit Pathfinding

```javascript
// Ch·ªâ t√≠nh pathfinding cho v√†i units ƒë·∫ßu, c√≤n l·∫°i follow leader
const leaders = selectedArray.slice(0, 3);
const followers = selectedArray.slice(3);

// Leaders t√≠nh path ri√™ng
leaders.forEach(leaderId => {
    // ... calculate path ...
});

// Followers follow leaders
followers.forEach(followerId => {
    // ... simple follow behavior ...
});
```

### 2. Cache Formation

```javascript
// L∆∞u formation positions ƒë·ªÉ kh√¥ng t√≠nh l·∫°i m·ªói frame
this.cachedFormation = {
    unitIds: selectedArray,
    positions: formationPositions,
    timestamp: Date.now()
};
```

---

## üéØ Next Steps

1. ‚úÖ **Phase 1**: Basic formation positioning
2. üîÑ **Phase 2**: Attack-Move auto-engage
3. üìà **Phase 3**: Dynamic formation (adjust while moving)
4. üß† **Phase 4**: Smart formation (avoid obstacles, split around buildings)


